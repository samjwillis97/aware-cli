package table

// https://github.com/charmbracelet/bubbles/blob/master/table/table.go
// See above for example

import (
	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/mattn/go-runewidth"
)

// Model defines a state for the table widget.
type model struct {
    KeyMap KeyMap

    cols []Column
    rows []Row
    cursor int
    focus bool
    styles Styles

    viewport viewport.Model
}

// Row represents one line in the table.
type Row []string

// Column defines the table structure.
type Column struct {
    Title string
    Width int
}

// KeyMap defines keybindings. It satisfies to the help.KeyMap interface, which
// is used to render the menu menu.
type KeyMap struct {
    LineUp key.Binding
    LineDown key.Binding
    PageUp key.Binding
    PageDown key.Binding
    GoToTop key.Binding
    GoToBottom key.Binding
}

// Styles contains style definitions for this list component. By default, these
// values are generated by DefaultStyles.
type Styles struct {
    Header lipgloss.Style
    Cell lipgloss.Style
    Selected lipgloss.Style
}

// Option is used to set options in New. For example:
//
//    table := New(WithColumns([]Column{{Title: "ID", Width: 10}}))
//
type Option func(*model)

// DefaultKeyMap returns a default set of keybindings.
func DefaultKeyMap() KeyMap {
    const spacebar = " "
	return KeyMap{
		LineUp: key.NewBinding(
			key.WithKeys("up", "k"),
			key.WithHelp("↑/k", "up"),
		),
		LineDown: key.NewBinding(
			key.WithKeys("down", "j"),
			key.WithHelp("↓/j", "down"),
		),
		PageUp: key.NewBinding(
			key.WithKeys("b", "pgup"),
			key.WithHelp("b/pgup", "page up"),
		),
		PageDown: key.NewBinding(
			key.WithKeys("f", "pgdown", spacebar),
			key.WithHelp("f/pgdn", "page down"),
		),
		GoToTop: key.NewBinding(
			key.WithKeys("home", "g"),
			key.WithHelp("g/home", "go to start"),
		),
		GoToBottom: key.NewBinding(
			key.WithKeys("end", "G"),
			key.WithHelp("G/end", "go to end"),
		),
	}
}

// DefaultStyles returns a set of default style definitions for this table.
func DefaultStyles() Styles {
    return Styles{
        Selected: lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("212")),
        Header: lipgloss.NewStyle().Bold(true).Padding(0, 1),
        Cell: lipgloss.NewStyle().Padding(0, 1),
    }
}

// New creates a new model for the table widget.
func New(opts ...Option) model {
    m := model{
        cursor: 0,
        viewport: viewport.New(0, 20),

        KeyMap: DefaultKeyMap(),
        styles: DefaultStyles(),
    }
    
    for _, opt := range opts {
        opt(&m)
    }

    m.UpdateViewport()

    return m
}

// UpdateViewport updates the list content based on the previously defined
// columns and rows.
func (m *model) UpdateViewport() {
    renderedRows := make([]string, 0, len(m.rows))
    for i := range m.rows {
        renderedRows = append(renderedRows, m.renderRow(i))
    }

    m.viewport.SetContent(
        lipgloss.JoinVertical(lipgloss.Left, renderedRows...),
    )
}

// WithTablulatedData sets both the table columns and rows from a single data variable
func WithTabulatedData(data [][]string) Option {
    var cols []Column
    var rows []Row
    for i, row := range data {
        if i == 0 {
            for _, col := range row {
                cols = append(cols, Column{Title: col})
            }
        } else {
            rows = append(rows, row)
        }
    }
    return func(m *model) {
        m.cols = cols
        m.rows = rows
    }
}

func WithFocused(f bool) Option {
    return func(m *model) {
        m.focus = f
    }
}

func (m model) Init() tea.Cmd {
    return nil
}

// Update is the Bubble Tea update loop.
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    if !m.focus {
        return m, nil
    }

    var cmds []tea.Cmd

    switch msg := msg.(type) {
    case tea.KeyMsg:
        switch msg.String() {
        case "ctrl+c", "q":
            return m, tea.Quit
        }
    }
    return m, tea.Batch(cmds...)
}

// View renders the component.
func (m model) View() string {
    return m.headersView() + "\n" + m.viewport.View()
}

func (m model) headersView() string {
	var s = make([]string, 0, len(m.cols))
	for _, col := range m.cols {
		style := lipgloss.NewStyle().Width(col.Width).MaxWidth(col.Width).Inline(true)
		renderedCell := style.Render(runewidth.Truncate(col.Title, col.Width, "…"))
		s = append(s, m.styles.Header.Render(renderedCell))
	}
	return lipgloss.JoinHorizontal(lipgloss.Left, s...)
}

func (m *model) renderRow(rowID int) string {
	var s = make([]string, 0, len(m.cols))
	for i, value := range m.rows[rowID] {
		style := lipgloss.NewStyle().Width(m.cols[i].Width).MaxWidth(m.cols[i].Width).Inline(true)
		renderedCell := m.styles.Cell.Render(style.Render(runewidth.Truncate(value, m.cols[i].Width, "…")))
		s = append(s, renderedCell)
	}

	row := lipgloss.JoinHorizontal(lipgloss.Left, s...)

	if rowID == m.cursor {
		return m.styles.Selected.Render(row)
	}

	return row
}
